"use-strict";

import global from "../globals.mjs";
import {join, basename} from "path";
import fs from "fs";

/**
 * This script builds the distributable npm-fs package to be published to npm.
 *
 * @remarks
 * This script requires an external source to set the name of the distributable
 * package root directory name. There are 2 ways this is obtained.
 *
 * By default, if no argument is provided, it attempts to use the npm config
 * property `dist_root_pkg_dirname` stored in the root npmrc of this package.
 *
 * Otherwise it attempts to use values passed via command line arguments. If one
 * cli arguments is passed, then that value is used. If 2 cli args are passed,
 * then only the second cli arg is used.
 *
 * This is done to make overriding the naming of the distributable npm package
 * root directory more customizable and prioritize any argument that is passed
 * as a command line argument when the npm script command is called. For
 * example, say an npm package has the following contents in its root `.npmrc`
 * and `package.json` files:
 *
 * npmrc
 * @example <caption>npmrc config properties</caption>
 * dist_root_pkg_dirname = "name-from-config-prop"
 *
 * package.json
 * @example <caption>build distributable script with no cli args</caption>
 * {
 *     "scripts": {
 *         "build-dist": "node scripts/build/build-dist.mjs"
 *     }
 * }
 *
 * @remarks
 * When the above script is run via the command `$npm run build-dist`, since no
 * arguments are passed to it, it attempts to use the npm config property value
 * set for `dist_root_pkg_dirname` which in this case is "name-from-config-prop".
 * So the name of the resulting built distributable package root directory will
 * be "name-from-config-prop".
 *
 * However, if the above script is called with a command line argument as
 * follows:
 *
 * `$npm run build-dist name-from-cli-arg`
 *
 * Then the name of the distributable package root directory that gets built
 * will be "name-from-cli-arg". Alternatively, a name argument can be written
 * into the script in `package.json` as follows:
 *
 * @example <caption>build distributable script with cli arg</caption>
 * package.json
 * {
 *     "scripts": {
 *         "build-dist": "node scripts/build/build-dist.mjs name-from-hard-coded-arg"
 *     }
 * }
 *
 * @remarks
 * The above example will result in the name of the built distributable npm
 * package root directory to be "name-from-hard-coded-arg". However, this name
 * can still be easily overridden by simply passing the desired name as command
 * line argument when the script is called, so even if there
 */

// fixme Passed cli argument needs to match directory name generated by tsc
//   --outDir in package.json script call to work

// Ensure that a package.json exists in the root directory of the npm project
if ( ! fs.existsSync(global.ROOT_PKG_JSON_FILE_PATH))
{
    throw new Error(`"${global.ROOT_PKG_JSON_FILE_PATH}" doesn't exist`);
}

// Ensure that the package.json element is a file
if ( ! fs.lstatSync(global.ROOT_PKG_JSON_FILE_PATH).isFile())
{
    throw new Error(`"${global.ROOT_PKG_JSON_FILE_PATH}" is not a file`);
}

// If no distributable root package directory name is provided via cli argument
// and no default dist_root_pkg_dirname npm config property is set
if (process.argv.length === 2
    && process.env.npm_config_dist_root_pkg_dirname === undefined)
{
    throw new Error("no default distributable root package directory name set"
                  + " or provided via cli argument");
}
// If more than 2 cli args are passed
else if (process.argv.length > 4)
{
    throw new Error(`0 to 2 command line argument(s) expected. ${process.argv.length - 2} arguments passed: ["${process.argv.slice(2).join('", "')}"]`);
}

const objectifyJsonFile = (pathToJsonFile, {omitKeys: keysToOmit, includeKeys: keysToInclude}) =>
{
    if (keysToOmit && keysToInclude)
    {
        throw new Error("Keys to omit and include simultaneously defined");
    }
    else if (keysToOmit?.length === 0)
    {
        throw new Error("Empty omit keys array");
    }
    else if (keysToInclude?.length === 0)
    {
        throw new Error("Empty include keys array");
    }

    // Ensure that a package.json exists in the root directory of the npm project
    if ( ! fs.existsSync(pathToJsonFile))
    {
        throw new Error(`"${pathToJsonFile}" doesn't exist`);
    }

    // Ensure that the package.json element is a file
    if ( ! fs.lstatSync(pathToJsonFile).isFile())
    {
        throw new Error(`"${pathToJsonFile}" is not a file`);
    }

    // Store the json file as a string
    const jsonFileString =
        fs.readFileSync(pathToJsonFile, {encoding: "utf-8"});

    // Parse json file to JavaScript object
    const originalJsObj = (jsonString =>
    {
        try
        {
            return JSON.parse(jsonString);
        }
        catch (err)
        {
            throw new Error(`error parsing package.json at "${pathToJsonFile}"`);
        }
    })(jsonFileString);

    const newJsObj =
        Object.fromEntries(Object.entries(originalJsObj)
                                 .filter(pkgJsonEntry =>
                                             // If specified keys to include, only include those keys
                                             keysToInclude?.includes(pkgJsonEntry[0])
                                             // If specified keys to exclude, include only keys that don't match those keys
                                             ?? ! keysToOmit?.includes(pkgJsonEntry[0])
                                             // If no keys specified to include or exclude, include all keys
                                             ?? true));

    const oldNewJsObjDiff =
        Object.keys(originalJsObj).filter(key => ! Object.keys(newJsObj).includes(key));

    if (oldNewJsObjDiff.length !== 0)
    {
        const oldNewJsObjIntersection =
            Object.keys(originalJsObj).filter(key => ! oldNewJsObjDiff.includes(key));

        console.log(`omitting keys from distributable package.json:\n["${oldNewJsObjDiff.join('", "')}"]\n`);

        console.log(`keys retained from npm root package.json:\n["${oldNewJsObjIntersection.join('", "')}"]\n`);

    }

    // New JS object with specified keys omitted or included
    return newJsObj;
};

const distPkgDirName = // If 2 command line arguments passed, use last one
                       process.argv.length === 4 ? process.argv[3]
                       // If a single cli arg is passed, use the cli arg
                     : process.argv.length === 3 ? process.argv[2]
                       // If no cli args are passed, use the default set npm
                       // config value
                     : process.env.npm_config_dist_root_pkg_dirname;

// Use provided cli argument to set name of root distributable package directory
const distPkgDirPath = join(global.BUILD_DIST_DIR_PATH, distPkgDirName);

// Set path to root README file to copy into distributable package root directory
const rootReadMePath =
    join(global.NPM_ROOT_DIR_PATH,
         fs.readdirSync(global.NPM_ROOT_DIR_PATH, {withFileTypes: true})
           .find(dirent => dirent.isFile() && /^README(\.(md|txt|rtf))?$/gi.test(dirent.name)).name);

// Set path to root LICENSE file to copy into distributable package root directory
const rootLicensePath =
    join(global.NPM_ROOT_DIR_PATH,
         fs.readdirSync(global.NPM_ROOT_DIR_PATH, {withFileTypes: true})
           .find(dirent => dirent.isFile() && /^LICENSE(\.(md|txt|rtf))?$/gi.test(dirent.name)).name);

// Create distributable package.json path
const distPkgJsonPath = join(distPkgDirPath, "package.json");

// Create distributable package.json object
const distPkgJsonObj = objectifyJsonFile(global.ROOT_PKG_JSON_FILE_PATH, {omitKeys: ["config", "devDependencies", "private", "scripts"]});

// If a root README file exists, copy it into root distributable package directory
if (fs.existsSync(rootReadMePath))
{
    const distReadMePath = join(distPkgDirPath, basename(rootReadMePath));

    fs.copyFile(rootReadMePath,
                distReadMePath,
                err => {
                    if (err) throw err;
                    else console.log(`README copied to:\n"${distReadMePath}"\n`);
                });
}

// If a root LICENSE file exists, copy it into root distributable package directory
if (fs.existsSync(rootLicensePath))
{
    const distLicensePath = join(distPkgDirPath, basename(rootLicensePath));

    fs.copyFile(rootLicensePath,
                distLicensePath,
                err => {
                    if (err) throw err;
                    else console.log(`LICENSE copied to:\n"${distLicensePath}"\n`);
                });
}

// Write distributable package.json object as string to resolved path
fs.writeFile(distPkgJsonPath,
             JSON.stringify(distPkgJsonObj, null, 2),
             {encoding: "utf-8"},
             err => {
                 if(err) throw err;
                 else console.log(`formatted dist package.json written to:\n"${distPkgJsonPath}"\n`);
             });
