"use-strict";

import global from "../globals.mjs";
import {join, basename} from "path";
import fs from "fs";

/**
 * This script builds the distributable npm-fs package to be published to npm.
 *
 * @remarks
 * This script requires an external source to set the name of the distributable
 * package root directory name. There are 2 ways this is obtained.
 *
 * By default, if no argument is provided, it attempts to use the npm config
 * property `dist_root_pkg_dirname` stored in the root npmrc of this package.
 *
 * Otherwise it attempts to use values passed via command line arguments. If one
 * cli arguments is passed, then that value is used. If 2 cli args are passed,
 * then only the second cli arg is used.
 *
 * This is done to make overriding the naming of the distributable npm package
 * root directory more customizable and prioritize any argument that is passed
 * as a command line argument when the npm script command is called. For
 * example, say an npm package has the following contents in its root `.npmrc`
 * and `package.json` files:
 *
 * npmrc
 * @example <caption>npmrc config properties</caption>
 * dist_root_pkg_dirname = "name-from-config-prop"
 *
 * package.json
 * @example <caption>build distributable script with no cli args</caption>
 * {
 *     "scripts": {
 *         "build-dist": "node scripts/build/build-dist.mjs"
 *     }
 * }
 *
 * @remarks
 * When the above script is run via the command `$npm run build-dist`, since no
 * arguments are passed to it, it attempts to use the npm config property value
 * set for `dist_root_pkg_dirname` which in this case is "name-from-config-prop".
 * So the name of the resulting built distributable package root directory will
 * be "name-from-config-prop".
 *
 * However, if the above script is called with a command line argument as
 * follows:
 *
 * `$npm run build-dist name-from-cli-arg`
 *
 * Then the name of the distributable package root directory that gets built
 * will be "name-from-cli-arg". Alternatively, a name argument can be written
 * into the script in `package.json` as follows:
 *
 * @example <caption>build distributable script with cli arg</caption>
 * package.json
 * {
 *     "scripts": {
 *         "build-dist": "node scripts/build/build-dist.mjs name-from-hard-coded-arg"
 *     }
 * }
 *
 * @remarks
 * The above example will result in the name of the built distributable npm
 * package root directory to be "name-from-hard-coded-arg". However, this name
 * can still be easily overridden by simply passing the desired name as command
 * line argument when the script is called, so even if there
 */

// fixme Passed cli argument needs to match directory name generated by tsc
//   --outDir in package.json script call to work

// Ensure that a package.json exists in the root directory of the npm project
if ( ! fs.existsSync(global.ROOT_PKG_JSON_FILE_PATH))
{
    throw new Error(`"${global.ROOT_PKG_JSON_FILE_PATH}" doesn't exist`);
}

// Ensure that the package.json element is a file
if ( ! fs.lstatSync(global.ROOT_PKG_JSON_FILE_PATH).isFile())
{
    throw new Error(`"${global.ROOT_PKG_JSON_FILE_PATH}" is not a file`);
}

// If no distributable root package directory name is provided via cli argument
// and no default dist_root_pkg_dirname npm config property is set
if (process.argv.length === 2
    && process.env.npm_config_dist_root_pkg_dirname === undefined)
{
    throw new Error("no default distributable root package directory name set"
                  + " or provided via cli argument");
}
// If more than 2 cli args are passed
else if (process.argv.length > 4)
{
    throw new Error(`1 command line argument expected. ${process.argv.length - 2} arguments passed: ["${process.argv.slice(2).join('", "')}"]`);
}

const formatRootPkgJsonForDist = pathToRootPkgJson =>
{
    // Ensure that a package.json exists in the root directory of the npm project
    if ( ! fs.existsSync(pathToRootPkgJson))
    {
        throw new Error(`"${pathToRootPkgJson}" doesn't exist`);
    }

    // Ensure that the package.json element is a file
    if ( ! fs.lstatSync(pathToRootPkgJson).isFile())
    {
        throw new Error(`"${pathToRootPkgJson}" is not a file`);
    }

    // Store the root package.json file as a string
    const rootPkgJsonString =
        fs.readFileSync(pathToRootPkgJson, {encoding: "utf-8"});

    // Return results from parsing package.json file
    const pkgJsonParseResult = (jsonString =>
    {
        try
        {
            return JSON.parse(jsonString);
        }
        catch (err)
        {
            throw new Error(`error parsing package.json at "${jsonString}"`);
        }
    })(rootPkgJsonString);

    // package.json properties to exclude from distributable package.json
    const rootPkgJsonPropsToExclude =
        ["config", "devDependencies", "private", "scripts"];

    // Distributable package.json JavaScript object
    const distPkgJsonObject =
        Object.fromEntries(Object.entries(pkgJsonParseResult)
                                 .filter(pkgJsonEntry => ! rootPkgJsonPropsToExclude.includes(pkgJsonEntry[0])));

    return JSON.stringify(distPkgJsonObject, null, 2);
};

const distPkgDirName = // If 2 command line arguments passed, use last one
                       process.argv.length === 4 ? process.argv[3]
                       // If a single cli arg is passed, use the cli arg
                     : process.argv.length === 3 ? process.argv[2]
                       // If no cli args are passed, use the default set npm
                       // config value
                     : process.env.npm_config_dist_root_pkg_dirname;

// Use provided cli argument to set name of root distributable package directory
const distPkgDirPath = join(global.BUILD_DIST_DIR_PATH, distPkgDirName);

// Set path to root README file to copy into distributable package root directory
const rootReadMePath =
    join(global.NPM_ROOT_DIR_PATH,
         fs.readdirSync(global.NPM_ROOT_DIR_PATH, {withFileTypes: true})
           .find(dirent => dirent.isFile() && dirent.name.match(/^README(\.(md|txt))?$/gi)).name);

// Set path to root LICENSE file to copy into distributable package root directory
const rootLicensePath =
    join(global.NPM_ROOT_DIR_PATH,
         fs.readdirSync(global.NPM_ROOT_DIR_PATH, {withFileTypes: true})
           .find(dirent => dirent.isFile() && dirent.name.match(/^LICENSE(\.(md|txt))?$/gi)).name);

// If a root README file exists, copy it into root distributable package directory
if (fs.existsSync(rootReadMePath))
{
    const distReadMePath = join(distPkgDirPath, basename(rootReadMePath));

    fs.copyFile(rootReadMePath,
                distReadMePath,
                err => {
                    if (err) throw err;
                    else console.log(`README copied to:\n"${distReadMePath}"`);
                });
}

// If a root LICENSE file exists, copy it into root distributable package directory
if (fs.existsSync(rootLicensePath))
{
    const distLicensePath = join(distPkgDirPath, basename(rootLicensePath));

    fs.copyFile(rootLicensePath,
                distLicensePath,
                err => {
                    if (err) throw err;
                    else console.log(`LICENSE copied to:\n"${distLicensePath}"`);
                });
}

const distPkgJsonPath = join(distPkgDirPath, "package.json");

// Write distributable package.json object as string to resolved path
fs.writeFile(distPkgJsonPath,
             formatRootPkgJsonForDist(global.ROOT_PKG_JSON_FILE_PATH),
             {encoding: "utf-8"},
             err => {
                 if(err) throw err;
                 else console.log(`formatted dist package.json written to:\n"${distPkgJsonPath}"`);
             });
